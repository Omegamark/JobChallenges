package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
)

func main() {
	if len(os.Args) < 2 {
		log.Fatalln("Please enter a file name...")
	}
	fileName := os.Args[1]

	// Make the directories for separate movie files.
	os.Mkdir(fileName+"_1080", 0700)
	os.Mkdir(fileName+"_720", 0700)
	os.Mkdir(fileName+"_540", 0700)
	os.Mkdir(fileName+"_432", 0700)
	os.Mkdir(fileName+"_360", 0700)

	command := "ffmpeg -i " + fileName + ` -s 1920x1080 -c:a aac -strict -2 -b:a 128k -c:v libx264 -g 72 -keyint_min 72 -b:v 6000k -hls_time 6 -hls_segment_filename ./` + fileName + `_1080/output_%03d.ts ./` + fileName + `_1080/output.m3u8
	 -s 1280x720 -c:a aac -strict -2 -b:a 128k -c:v libx264 -g 72 -keyint_min 72 -b:v 4000k -hls_time 6 -hls_segment_filename ./` + fileName + `_720/output_%03d.ts ./` + fileName + `_720/output.m3u8
	 -s 960x540 -c:a aac -strict -2 -b:a 128k -c:v libx264 -g 72 -keyint_min 72 -b:v 2000k -hls_time 6 -hls_segment_filename ./` + fileName + `_540/output_%03d.ts ./` + fileName + `_540/output.m3u8
	 -s 768x432 -c:a aac -strict -2 -b:a 128k -c:v libx264 -g 72 -keyint_min 72 -b:v 1500k -hls_time 6 -hls_segment_filename ./` + fileName + `_432/output_%03d.ts ./` + fileName + `_432/output.m3u8
	 -s 640x360 -c:a aac -strict -2 -b:a 128k -c:v libx264 -g 72 -keyint_min 72 -b:v 1100k -hls_time 6 -hls_segment_filename ./` + fileName + `_360/output_%03d.ts ./` + fileName + `_360/output.m3u8
	 `

	parts := strings.Fields(command)

	cmd := exec.Command(parts[0], parts[1:]...)
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout

	err := cmd.Run()
	if err != nil {
		log.Fatal(err)
	}

	createManifest(fileName)
}

func createManifest(fileName string) {
	f, err := os.Create("./main.m3u8")
	if err != nil {
		panic(err)
	}
	defer f.Close()
	// Create the writer to pass to the writeManifest function
	w := bufio.NewWriter(f)
	// Write in manifest file heading
	w.Write([]byte("#EXTM3U\n"))
	// I don't like this part as much now that I've done it. I wanted to use walk, but this could be made clearer.
	// Walk is acting like a for loop, validating the folders containing movie files and performing operations on them.
	err = filepath.Walk("./", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			fmt.Printf("prevent panic by handling failure accessing a path %q: %v\n", path, err)
			return err
		}

		if info.IsDir() == true {
			movieDir, err := regexp.MatchString(fileName+"*", path)
			if err != nil {
				log.Fatal(err)
			}
			if movieDir == true {
				numFiles, err := fileCount(path)
				if err != nil {
					log.Fatal(err)
				}
				var bitRates []int
				var frameRate int
				var avgBandwidth int
				// Check that numFiles is less than 10, otherwise, NOT MVP
				// Need to reconcile this (%03d) part of the filename generated by ffmpeg, simple fix but need to turn in the challenge.
				if numFiles < 10 {
					i := 0
					for i < numFiles {
						cmd := exec.Command("ffprobe", path+"/output_00"+strconv.Itoa(i)+".ts")
						// Must admit I'm a little confused here.
						// var output, errb bytes.Buffer
						var errb bytes.Buffer

						// cmd.Stdout = &output
						cmd.Stderr = &errb // Not sure why output is being put here, in Stderr and NOT Stdout, seems quirky
						err = cmd.Run()
						if err != nil {
							log.Fatal(err)
						}
						fileMeta := errb.String()
						bitRates = findBitRates(fileMeta, bitRates)
						// Checks every time, change so it only does a single check.
						frameRate = findFrameRate(fileMeta)
						i++
					}
					avgBandwidth = averageBitRates(numFiles, bitRates)
					writeToManifest(frameRate, avgBandwidth, w, path, fileName)
				} else {
					log.Fatalln("More than 10 movie segments is NOT MVP at this time")
				}
			}
		}
		return nil
	})
	if err != nil {
		log.Fatal(err)
	}
	w.Flush()
	fmt.Println("Program Complete")
}

func writeToManifest(frameRate int, avgBandwidth int, w *bufio.Writer, path string, fileName string) {
	bandwidth := ""
	resolution := ""
	switch path {
	case fileName + "_1080":
		bandwidth = "6000000"
		resolution = "1920x1080"
	case fileName + "_720":
		bandwidth = "4000000"
		resolution = "1280x720"
	case fileName + "_540":
		bandwidth = "3000000"
		resolution = "960x540"
	case fileName + "_432":
		bandwidth = "2000000"
		resolution = "768x432"
	case fileName + "_360":
		bandwidth = "1100000"
		resolution = "640x360"
	default:
		log.Fatalln("switch statement received something wierd for resolution output.")
	}

	manifest := []byte(
		`#EXT-X-STREAM-INF:BANDWIDTH=` + bandwidth + `,AVERAGE-BANDWITH=` + strconv.Itoa(avgBandwidth) + `000` + `,FRAME-RATE=` + strconv.Itoa(frameRate) + `,RESOLUTION=` + resolution + `,CODECS="H.264"
./` + path + `/output.m3u8
`)
	w.Write(manifest)
}

func averageBitRates(numFiles int, bitRates []int) int {
	bitRateSum := 0
	for _, v := range bitRates {
		bitRateSum += v
	}
	return bitRateSum / numFiles
}

func findBitRates(fileMeta string, bitRates []int) []int {
	fields := strings.Fields(fileMeta)
	for i, v := range fields {
		if v == "bitrate:" {
			bitRateSafeString := strings.Trim(fields[i+1], "")
			bitRate, err := strconv.Atoi(bitRateSafeString)
			if err != nil {
				log.Fatalln(err)
			}
			bitRates = append(bitRates, bitRate)
		}
	}
	return bitRates
}

func findFrameRate(fileMeta string) int {
	fields := strings.Fields(fileMeta)
	for i, v := range fields {
		// I don't like this check either, but will fix when refactor.
		if v == "fps," {
			frameRateSafeString := strings.Trim(fields[i+1], "")
			frameRate, err := strconv.Atoi(frameRateSafeString)
			if err != nil {
				log.Fatalln(err)
			}
			return frameRate
		}
	}
	fmt.Println("We didn't find fps")
	return 0
}

func fileCount(path string) (int, error) {
	i := 0
	ext := ".ts"
	files, err := ioutil.ReadDir(path)
	if err != nil {
		return 0, err
	}
	for _, file := range files {
		if !file.IsDir() {
			checkFileExt, err := regexp.MatchString(ext, file.Name())
			if err != nil {
				log.Fatal(err)
			}
			if checkFileExt == true {
				i++
			}
		}
	}
	return i, nil
}
